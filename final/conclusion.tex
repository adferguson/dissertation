\chapter{Conclusion}
\label{sec:conclusion}

This dissertation has presented prototypes of two novel contributions to
software-defined networking. The first, \sys, allows network administrator's
to safely delegate their authority over the network's policy.
The design and configuration of today's networks is already informed
by application needs (\eg,
networks with full-bisection bandwidth for MapReduce-type frameworks,
or deadline-based queuing~\cite{Ballani:2011} for interactive web services).
\sys provides a way for the network to solicit and react to such needs
automatically, dynamically, and at a finer timescale than with human input.
To do this, our design overcomes the two challenges of decomposing network
control, and resolving conflicts between users' needs.

%Reiterate how \sys is about exposing network capabilities and information
%to the end-users. We believe that it can be used as a building-block for other
%proposals, and it could be integrated alongside other applications in an SDN
%controller (eg, load-balancing, Hotel/Campus authentication portals, firewalls
%and other security applications such as the HoneyNet work, etc.)

However, before using a novel SDN controller such as \sys, many administrators
will wish to migrate their existing configurations to the new platform.
Our second contribution,
Exodus, is the first SDN migration tool which directly migrates existing network
policies to equivalent SDN controller software and an OpenFlow-based
network configuration. Automatic migration allows network operators familiar
with their own networks, but not SDN, to quickly explore the benefits of this new
approach.
By generating code in a high-level, rule-based language, Exodus
makes it easy to bootstrap a new network controller which can evolve
at the frenetic pace of enterprise network environments~\cite{kim11evolution}.
The high-level semantics of the generated program opens the avenue
for change-impact analysis, and potential refactoring of the physical 
configuration of the network, bringing the full benefits of an SDN
deployment.
No matter the migration strategy eventually employed, Exodus gives
network administrators a concrete, working prototype from which to begin
discussion and compare solutions.

\section{Bringing \sys to Flowlog}
\label{sec:pane-in-flowlog}

At present, controllers for software-defined networks are in their infancy, and
most controllers are built to accomplish particular objectives: \sys the challenge of policy
delegation, and Exodus, the task of policy migration. As we consider the further
growth and maturation of software-defined networking, we can begin with exercise
of implementing \sys in Flowlog, the language in which Exodus controllers are generated.

Flowlog's initial design was heavily influenced by our experience building \sys.
The \sys controller is fundamentally event-driven, as new network configurations
are driven by the dynamic requests arriving from end users. It also stores a lot of state
about the network: host locations, bandwidth availability, access control lists, switch
and link statuses, timelines of future requests, and more. The central nature of both events
and state made \sys a poor match for the existing SDN languages.

Because Flowlog was designed around events and state, implementing \sys in Flowlog
might appear straight-forward. Several components of the \sys runtime such as host
discovery, topology discovery, spanning-tree construction, and forwarding decisions,
could be replaced with well-built NIB and forwarding programs in the current Flowlog.
Furthermore, much of the \sys API is exposed to it's users assuming a ``one big switch''
abstraction of the network, which aligns with that of the NetCore policies Flowlog generates.

However, we find that Flowlog currently falls short in two key areas: composition, and routing.
In Flowlog's present design, all event handlers are triggered at once -- it is not possible to
first evaluate an incoming packet with, for example, an access-control module (or \sys), and
then second with a forwarding module. While the physical composition employed by Exodus
is immune to this problem, \sys requires logical composition as its policies will not necessarily
yield a complete end-to-end routing assignment for all packets.

Indeed, this example is directly related to Flowlog's second key shortcoming: \sys policies may
simply declare that some packets should be waypointed through a particular switch before
reaching their destination. Such a policy, like any which introduces topological constraints,
would be challenging to implement in Flowlog, which only provides either a hop-by-hop or
a ``one big switch'' approach to network programming.

\section{Limitations of the ``One Big Switch'' Abstraction}
\label{sec:one-big-switch}

\sys is not the only SDN application which cannot always be implemented in a ``one big switch''
view of the network. Other examples include:

\begin{itemize}
\item {\bf Guaranteed latency} -- The end-to-end latency a flow experiences is a function of
many variables, including the choice of path. An SDN application designed to manage flow
latencies will require details of the network topology. For example, in a Clos datacenter network,
latency is a function of the number of switches (and therefore links) a packet traverses.

\item {\bf Circuit provisioning} -- Many scientific WANs are designed to provision optical circuits
on demand, either for bulk data dissemination (\eg, in ESNet) or to isolate experimental traffic
(\eg, in GENI). Such applications are a particular form of wide-area traffic engineering, and
obviously break the ``one big switch'' abstraction.

\item {\bf Scheduled maintenance} -- A controller application designed to seamlessly migrate
traffic ahead of scheduled maintenance necessarily requires information about the network's
physical infrastructure (\eg, the bandwidth available on each link, which links will be taken
offline by switch maintenance, which links share the same optical cable, etc.)
\end{itemize}

From these examples, we see that the ``one big switch'' abstraction works best under two
assumptions: first, that the network is uniform, and second, that applications are topology-independent.
When networks are not uniform (\eg, a WAN with many different link costs), or applications
make topology-dependent decisions (\eg, to control latency, or schedule maintenance) then
the controller must expose topology information through a NIB, and should provide a path
programming abstraction.

\section{Lessons from Building SDN Controllers}
\label{sec:building-controllers}

Useful features of an SDN controller platform:
\begin{enumerate}
\item tables (state) -- routing, forwarding, NAT, ARP cache, ACLs, and the NIB
\item events -- host up, host down, switch up, switch down, etc. plus external events
\item policy composition -- sequential, parallel, prioritized, and hierarchical merge
\item path construction -- traffic engineering, tunneling, etc. ... eg, how B4 works, and GMB in PANE.
\item virtualization -- which is two sub-components:
	\begin{itemize}
	\item indirection layer: writing a policy on a virtualized view of the network (eg, one big switch, or a particular slice)
	\item isolation between tenants (whether overlapping or not)
	\end{itemize}
\item scalable implementation -- grow with the number of switches and packets
\item redundant implementation (multiple controllers)
\item verification of control programs
\item debugging functionality (eg, the ability to capture and replay packet histories)
\item switch resource management
\item illusion of infinite rule space on the switches  (like virtual memory provides)
\item consistent updates and transactional updates
\item a query engine -- infrastructure for performing queries and handling responses at a level the hardware can support
\item intelligent use of tables -- strategies for optimal placement of rules in the network, and use of heterogenous switch hardware
\item enforcement of security requirements
\end{enumerate}


